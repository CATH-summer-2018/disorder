#!/usr/bin/python
'''
Variety of functions and classes for working with CATH domains. Mostly relies on results generated by iupred, nDOPE and SSAP
'''
import requests
import os
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import scipy
import seaborn as sns
import plotly
import plotly.graph_objs as go
import plotly.plotly as py
import plotly.figure_factory as ff
import py3Dmol

### PLOTS
def plot_stats(df, col, val,
              title=False, savedname=False):
    plt.rcParams['font.size'] = 24
    fig, ax = plt.subplots(figsize=(10,10))
    for t in df[col].unique():
        ax.bar(t, df[df[col] == t][val].mean(), width=0.7)
    plt.ylabel(val)
    plt.xlabel(col)
    ax.axhline(y=0, color='k')
    if title:
        plt.title(title)
    if savedname:
        plt.savefig(savedname, bbox_inches='tight')
    plt.show()

def exclude_missing_data(matrix):
    '''
    Cleans the distance matrix to remove domains with missing SSAP/overlap scores
    '''
    if matrix.count().min() == matrix.count().max():
        return matrix
    include = matrix[matrix.count() != matrix.count().min()]
    return include[include.index]

def plot_dendro(sfam, method='ssap', show='jup'):
    '''
    Plots dendrogram from the distance matrix (SSAP/overlap)
    '''
    if method == 'ssap':
        directory = './distance_matrices/'
    elif method == 'over':
        directory = './percent_overlap/'
    else:
        print('Unknown method')
        return
    t = exclude_missing_data(fetch_sfam_matrix(sfam, method=method))
    names = t.index
    dendro = ff.create_dendrogram(t.fillna(0), labels=names)
    dendro['layout'].update({'width':800, 'height':500})
    if show == 'jup':
        plotly.offline.iplot(dendro, filename='simple_dendrogram')
    elif show == 'html':
        plotly.offline.plot(dendro, filename='simple_dendrogram')
    else:
        print("Unknown show method")

def fetch_sfam_matrix(sfam_id, method='ssap'):
    '''
    Internal method for pulling the distance matrix from local files
    '''
    if method == 'ssap':
        directory = './distance_matrices/'
    elif method == 'over':
        directory = './percent_overlap/'
    else:
        print('Unknown method')
        return
    return pd.read_csv(directory+sfam_id, sep='\t', index_col=0)

def plt_scatter(s, col1, col2,
                col_cutoff=False, cutoff=False,
                savedname=False, title=False, marksize=15):
    '''
    Plots the scatter plot for 2 columns in the dataframe
    '''
    fig, ax = plt.subplots(figsize=(15,15))
    x = s.sort_values(by=col1)[col2].values
    y = s.sort_values(by=col1)[col1].values
    ax.set_xlim(min(x), max(x))
    ax.set_ylim(min(y), max(y))
    ax.set_xlabel(col2)
    ax.set_ylabel(col1)
    if col_cutoff:
        under = s[s[col_cutoff] < cutoff]
        over = s[s[col_cutoff] >= cutoff]
        x_under = under.sort_values(by=col1)[col2].values
        y_under = under.sort_values(by=col1)[col1].values
        x_over = over.sort_values(by=col1)[col2].values
        y_over = over.sort_values(by=col1)[col1].values
        ax.scatter(x_under, y_under, s=marksize, marker='x', c='#1E70AA')
        ax.scatter(x_over, y_over, s=marksize, marker='x', c='blue')
    else:
        ax.scatter(x, y, s=marksize, marker='.', c='#1E70AA')
    if title:
        plt.title(title)
    if savedname:
        plt.savefig(savedname, bbox_inches='tight')
    plt.show()


def plt_scatter_discrete(s, col1, col2,
                col_colour=False,
                savedname=False, title=False, marksize=15):
    '''
    Plots the scatter plot for 2 columns in the dataframe and gives differing colout based on 3rd column
    '''
    fig, ax = plt.subplots(figsize=(15,15))
    x = s.sort_values(by=col1)[col2].values
    y = s.sort_values(by=col1)[col1].values
    ax.set_xlim(min(x), max(x))
    ax.set_ylim(min(y), max(y))
    ax.set_xlabel(col2)
    ax.set_ylabel(col1)
    values = s[col_colour].value_counts().index.tolist()
    graphlist = []
    for value in values:
        colour = s[s[col_colour] == value]
        x_colour = colour.sort_values(by=col1)[col2].values
        y_colour = colour.sort_values(by=col1)[col1].values
        graphlist.append(ax.scatter(x_colour, y_colour, s=marksize, marker='x'))
    plt.legend(graphlist, values)
    if title:
        plt.title(title)
    if savedname:
        plt.savefig(savedname, bbox_inches='tight')
    plt.show()

def plt_inter_scatter_discrete(s, col1, col2, col_colour, savedname='./figs/tmp.html', show='jup',
                 title=False, marksize=10):
    '''
    Plots the interactive scatter plot for 2 columns in the dataframe with plotly
    '''
    values = s[col_colour].value_counts().index.tolist()
    data = []
    colormap = ['#ff0000', '#00aa00', '#0000ff', '#ff00ff']
    for value in values:
        colour = s[s[col_colour] == value]
        x_colour = colour.sort_values(by=col1)[col1].values
        y_colour = colour.sort_values(by=col1)[col2].values
        trace=go.Scatter(
            name=value,
            x=x_colour,
            y=y_colour,
            mode = 'markers',
            marker=dict(size=5,color=colormap[values.index(value)]),
                    hoverinfo='text',
            text= 'ID: ' + colour.index + '<br> ' + col1 + ': ' + x_colour.round(3).astype(str) + '<br>'+ col2 + ': ' + y_colour.round(3).astype(str),
            line=dict(width=2))
        data.append(trace)

    layout = go.Layout(dict(hovermode='closest',
    title = 'Scatterplot for ' + col1 + ' and ' + col2 + ' coloured by ' + col_colour,
    xaxis= dict(
        title=col1,
        ticklen= 5,
        zeroline= False,
        gridwidth= 2,
    ),
    yaxis=dict(
        title=col2,
        ticklen= 5,
        gridwidth= 2,
    )))
    fig = go.Figure(data, layout)
    if show == 'jup':
        plotly.offline.iplot(fig)
    elif show == 'html':
        plotly.offline.plot(fig, filename=savedname)

def plt_regplot(s, col1, col2,
                savedname=False, title=False):
    '''
    Plots the scatter plot for 2 columns in the dataframe with regression line
    '''
    fig, ax = plt.subplots(figsize=(15,15))
    x = s.sort_values(by=col1)[col2].values
    y = s.sort_values(by=col1)[col1].values
    ax.set_xlim(min(x), max(x))
    ax.set_ylim(min(y), max(y))
    ax.set_xlabel(col2)
    ax.set_ylabel(col1)
    sns.regplot(x, y,
    scatter_kws={"s": 5},
    line_kws={'color':'blue'},
    marker='.',ci=None)
    if title:
        plt.title(title)
    if savedname:
        plt.savefig(savedname, bbox_inches='tight')
    plt.show()

def plot_clustermap(data, annot=False, savedname=False, fixsize=False):
    '''
    Plots heatmap from the distance matrix with the dendrograms
    '''
    my_cmap = sns.diverging_palette(240, 10, n=9, as_cmap=True)
    if fixsize:
        sns.clustermap(exclude_missing_data(data).fillna(100),
        annot=annot,
        figsize=data.shape,
        method='average',
        vmin=0, vmax=100, fmt='.0f')
    else:
        sns.clustermap(exclude_missing_data(data).fillna(100),
        annot=annot,
        figsize=(12,12),
        method='average',
        vmin=0, vmax=100, fmt='.0f')


    if savedname:
        plt.savefig(savedname, bbox_inches='tight')
    plt.show()


### CLASSES

# class Domain(object):
#     '''
#     Class for fetching stuff for a domain
#     '''
#     def __init__(self, df, domain):
#         self.domain = domain
#         self.long = pd.read_csv('./individual_fasta/'+df.loc[domain]['SFAM']+'/'+domain+'.long', sep='\t', index_col=0)
#         self.short = pd.read_csv('./individual_fasta/'+df.loc[domain]['SFAM']+'/'+domain+'.short', sep='\t', index_col=0)
#
#     def plot_disorder(self, method='both'):
#         '''
#         Plots the disorder for individual domain
#         '''
#         fig, ax = plt.subplots(figsize=(15,5))
#         ax.plot([0, len(self.long)], [0.5,0.5], color='black', linewidth=0.7)
#         ax.set_xlim(0, len(self.long))
#         ax.set_ylim(0,1)
#         if method == 'long':
#             ax.plot(self.long.DIS)
#         elif method == 'short':
#             ax.plot(self.short.DIS)
#         elif method == 'both':
#             ax.plot(self.long.DIS, color='blue', label='LONG')
#             ax.plot(self.short.DIS, color='orange', label='SHORT')
#             plt.legend()
#         else:
#             print("Wrong method")
#         plt.show()


def show_structure(domain, full=False):
    '''
    Uses py3Dmol and requests to fetch domain PDB and show it in jupyter
    '''
    view = py3Dmol.view()

    def adjust_looks(view):
        view.setStyle({'cartoon':{'colorscheme':'ssJmol'}})
        view.center()
        return view
    if full:
        prot = domain[:4].upper()
        if (prot + '.pdb') in os.listdir('structures'):
            with open('./structures/'+prot+'.pdb') as file:
                view.addModel(file.read(), 'pdb')
        else:
            r = requests.get('https://files.rcsb.org/download/' + prot + '.pdb')
            with open('./structures/' + prot + '.pdb', 'w') as file:
                file.write(r.text)
            view = view.addModel(r.text, 'pdb')
    else:
        if (domain + '.pdb') in os.listdir('structures'):
            with open('./structures/'+domain+'.pdb') as file:
                view.addModel(file.read(), 'pdb')
        else:
            r = requests.get('http://www.cathdb.info/version/v4_2_0/api/rest/id/' + domain + '.pdb')
            with open('./structures/' + domain + '.pdb', 'w') as file:
                file.write(r.text)
            view = view.addModel(r.text, 'pdb')
    return adjust_looks(view)


class DomParser(object):
    '''
    Methods for quick work with domains DataFrame
    '''
    def __init__(self, df):
        self.df = df

    def get_sfam(self, sfam):
        '''
        Extracts all domains from one sfam
        '''
        return self.df[self.df['SFAM'] == sfam]


    def scrape_sfam(self, gr):
        '''
        Compiles information for each CATH superfamily rather than each domain
        '''
        dom_len = pd.Series()
        std_len = pd.Series()
        max_len = pd.Series()
        min_len = pd.Series()
        long = pd.Series()
        short = pd.Series()
        std_long = pd.Series()
        std_short = pd.Series()
        sample = pd.Series()
        for n, d in gr:
            short[n] = d.SHORT.mean()
            long[n] = d.LONG.mean()
            std_short[n] = d.SHORT.std().round(6)
            std_long[n] = d.LONG.std().round(6)
            dom_len[n] = d.LEN.mean().round(6)
            std_len[n] = d.LEN.std().round(6)
            min_len[n] = d.LEN.min()
            max_len[n] = d.LEN.max()
            sample[n] = d.SHORT.idxmax()
        size = self.df.SFAM.value_counts()
        sfam = pd.DataFrame({'SIZE' : size,
                             'STD_SHORT' : std_short,
                             'STD_LONG' : std_long,
                             'LEN' : dom_len,
                             'STD_LEN' : std_len,
                             'SHORT' : short,
                            'LONG':long,
                            'MAX_LEN' : max_len,
                            'MIN_LEN' : min_len,
                            'SAMPLE':sample})
        return sfam

    def compile_sfam(self):
        '''
        Runs scrape_sfam for each superfamily using groupby
        '''
        gr = self.df.groupby('SFAM')
        sfam = self.scrape_sfam(gr)
        sfam['DIS_DIFF'] = (sfam['LONG'] - sfam['SHORT']).abs().round(6)
        sfam['STD_LEN_PERC'] = sfam['STD_LEN_PERC'] = sfam['STD_LEN']/sfam['LEN']
        return sfam

    def plot_len_distr(self, sfam):
        '''
        Plots the length distribution as histogram for CATH superfamily
        '''
        fig, ax = plt.subplots(figsize=(10,10))
        data = self.get_sfam(sfam).LEN.values

        ax.hist(data,
                25,
                edgecolor='black')
        ax.set_xlim(0, max(data)*1.1)
        plt.xlabel('Length')
        plt.ylabel('Number of domains')
        plt.show()


### CALCULATIONS


def distance_matrix(df, sfam_id, metric):
    '''
    Returns distance matrix for one sfam
    '''
    sfam = df[df.query_superfamily_id == sfam_id]
    cols = pd.concat([sfam.query_id, sfam.match_id]).unique()
    t = pd.DataFrame(index=cols)
    for item in cols:
        w = sfam[(sfam.query_id == item) | (sfam.match_id == item)]
        w['match'] = w.query_id.combine(w.match_id, lambda x, y: x if x != item else y)
        w.drop_duplicates(subset='match', keep='last', inplace=True)
        w.set_index('match', inplace=True)
        t[item] = w[metric]
    return t

def write_matrices(ssap, ind, metric, location):
    '''
    Saves the distance matrices locally
    '''
    for i in ind:
        t = distance_matrix(ssap, i, metric)
        t.to_csv(location+i, sep='\t')



def compile_means(sfam):
    '''
    Gets mean for SSAP and overlap for one sfam
    '''
    ssap = pd.read_csv('./distance_matrices/'+sfam, sep='\t')
    over = pd.read_csv('./percent_overlap/'+sfam, sep='\t')
    ret = pd.DataFrame({"SSAP" : ssap.mean(),
                        "STD_SSAP" : ssap.std(),
                        "OVER" : over.mean(),
                       "STD_OVER" : over.std()})
    return ret



# def study_matrices(ind):
#     mean_SSAP = pd.Series()
#     min_SSAP = pd.Series()
#     mean_std_SSAP = pd.Series()
#     for i in ind:
#         t = pd.re
#         mean_SSAP[i] = t.mean()
#         min_SSAP[i] = t.min()
#         mean_std_SSAP[i] = t.std()
#     return pd.DataFrame({'MEAN_SSAP':mean_SSAP,
#                         'MIN_SSAP':min_SSAP,
#                         'MEAN_STD_SSAP':mean_std_SSAP})
